# -*- mode: fvwm -*-
# ====================[ main                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Fluviol, a minimalist theme for FVWM[-Crystal] emphasizing ascetic aesthetics,
# virtual desktops, keyboard- and console-centric usability, and Zsh-driven
# extensibility (e.g., wallpaper rotation, Kuake consoles).
#
# --------------------( TODO                               )--------------------
# * I finally realized why closing application dialogs switches to the current
#   desktop's fluake rather than the application itself. As these things go,
#   it's appallingly simple once you actually consider it: when in an
#   application, the most recently focused application was probably that fluake;
#   when in a dialog, the most recently focused application appears to *STILL*
#   be that fluake when (obviously) it should be that application. The only
#   logical reason why this would be is that opening and focusing a dialog does
#   not appear to trigger a change to the variable recording "the most recently
#   focused application" in our current implementation. We should really track
#   this down. It's annoying as heck.
# * H0LY MOTHER OF THE GODDESS! I'm using a roughly three year-old snapshot
#   of Zeshy here! Just check "fvwm/global". Jeebus. I mean... what? How did
#   this never come up? This needs to default to "$[ZESHY_HOME]" immediately.
#   In fact, why the heck do we need a separate "$[FLUVIOL_ZESHY_HOME]"
#   polluting the namespace? We don't. Cut it.

# ....................{ PATHS                              }....................
#FIXME: Throw a visual exception and load FVWM, instead, if this path cannot be
#found. Also, why can't we just default to the $[PWD]? (*IS* there a $[PWD]?)

# Absolute path of the top-level Fluviol directory. Ideally, the external caller
# sets this on our behalf. If not, default to the directory with this script.
Test (!EnvIsSet FLUVIOL_HOME) SetEnv FLUVIOL_HOME "$[.]"

# Absolute path of the Fluviol FVWM script directory.
SetEnv FLUVIOL_FVWM_DIR "$[FLUVIOL_HOME]/fvwm"

#FIXME: Uhm; why do we need this? Seems a tad silly. If we really need this,
#can't the "main" script find its own absolute path? Poor name, in any case.
# Absolute path of this FVWM script.
SetEnv FLUVIOL_RC_FILE "$[FLUVIOL_HOME]/main"

# ....................{ FUNCTIONS                          }....................
#FIXME: Rename to DefineFunction().
# void DefineFunc(string functionName, string functionCode)
#
# Define the passed function with the passed implementation.
DestroyFunc DefineFunc
  AddToFunc DefineFunc
+ I DestroyFunc $0
+ I   AddToFunc $*

# Prevent windows from claiming "urgency." (Typically, FVWM forcefully warps
# to each window which claims it urgently needs attention. Don't allow that.)
# Do this early, so as to avoid unpleasantness later.
DefineFunc UrgencyFunc
+ I Nop

DefineFunc UrgencyDoneFunc
+ I Nop

# ....................{ MODULES                            }....................
# void LoadModule(string moduleName, string moduleArg1, string moduleArg2, ...)
#
# Load the passed module with the passed parameters.
DefineFunc LoadModule
+ I KillModule $0
+ I     Module $*

# ....................{ FUNCTIONS ~ logs                   }....................
#FIXME: Since we're defining our own "/usr/bin/fluviol", there's no reason we
#can't explicitly do this there. Make it so.
# FVWM logs stderr (but not stdout) to "~/.xsession-errors", by default. To make
# FVWM log stderr and stdout to a file "~/.xsession", start Fluviol via:
#       startx > ~/.xsession 2>&1

# void Log(string Message)
#
# Log the passed message to the FVWM logfile.
DefineFunc Log
+ I SetTimestamp
+ I Echo [$[FLUVIOL_TIMESTAMP]] fluviol: $*

# void LogError(string ErrorMessage)
#
# Log the passed error message to the FVWM logfile.
DefineFunc LogError
+ I SetTimestamp
+ I Echo [$[FLUVIOL_TIMESTAMP]] fluviol! $*

#FIXME: Why the "KeepRc" here? We *WANT* to return with error status, right?
#Where is this actually called?
# void LogAndBreak(string Message)
#
# Log the passed message to the FVWM logfile and "break" (i.e., immediately
# return with error status) from the calling function.
DefineFunc LogAndBreak
+ I Log $*
+ I KeepRc Break 2

# void LogErrorAndBreak(string ErrorMessage)
#
# Log the passed error message to the FVWM logfile and "break" from the calling
# function.
DefineFunc LogErrorAndBreak
+ I LogError $*
+ I Break 2

# void SetTimestamp(void)
#
# Set "FLUVIOL_TIMESTAMP", a string global expanding to the human-readable time
# at which this function was last called.
DefineFunc SetTimestamp
+ I PipeRead 'echo SetEnv FLUVIOL_TIMESTAMP $(date +"%F~%H:%M:%S")'

# Log a startup message as soon as possible (i.e., on defining SetTimestamp()).
Log loading "$[FLUVIOL_RC_FILE]"...

#FIXME: O.K.; shift all functions that follow defining the core Fluviol language
#into a new "core" component. The existing Import() function calls a few such
#functions, so just implement the equivalent import logic manually here.

# ....................{ FUNCTIONS ~ flow                   }....................
# void Return(void)
#
# Return from the calling function without changing the current return code.
DefineFunc Return
+ I KeepRc Break 2

# void ReturnMatch(void)
#
# Return from the calling function with return code "Match" (i.e., 1).
DefineFunc ReturnMatch
+ I SetReturnCodeToMatch
+ I Return

# void ReturnError(void)
#
# Return from the calling function with return code "Error" (i.e., -1).
DefineFunc ReturnError
+ I SetReturnCodeToError
+ I Return

#FIXME: Great! But how to set the current return code to "NoMatch" (i.e., 0)? I
#suppose we'd need to conjure up a condition guaranteed to never match:
#something inherently contradictory should suffice, yes?

# void SetReturnCodeToMatch(void)
#
# Set the current return code to "Match" (i.e., 1), signifying success.
DefineFunc SetReturnCodeToMatch
+ I PipeRead true

# void SetReturnCodeToError(void)
#
# Set the current return code to "Error" (i.e., -1), signifying fatal error.
DefineFunc SetReturnCodeToError
+ I PipeRead false

# void OrDie(string ErrorMessage)
#
# If the current return code (as returned by the prior FVWM command) indicates
# "NoMatch", "Error", or "Break", log the passed error message to the FVWM
# logfile and break from the calling function.
#
# Note: this function avoids changing the value of $[cond.rc], the return code
# of the prior FVWM function. This allows later functions to perform independent
# testing of the return code, which is probably nice.
DefineFunc OrDie
+ I TestRc (Match) Return
+ I KeepRc LogErrorAndBreak $*

# ....................{ FUNCTIONS ~ variables              }....................
#FIXME: Rename to SetVariableIfUnset(). *EVERYWHERE* we say "SetEnv..." should,
#in fact, be "SetVariable...". Slightly longer, but much more readable.
# void SetEnvIfUnset(string VariableName, string VariableValue)
#
# Set the passed environment variable, if currently unset, to the passed string.
DefineFunc SetEnvIfUnset
+ I Test (!EnvIsSet $0) SetEnv $*

#FIXME: Rename to SetEnvToFile().
# void SetFile(string VariableName, string Filename)
#
# Set the passed environment variable to the passed absolute path. If there
# exists no file at this path, or there does but the file is not readable, log
# an error.
DefineFunc SetFile
+ I SetEnv $[0] $[1]
+ I PipeRead '[ -f "$[1]" ] && [ -r "$[1]" ] || \
    echo LogErrorAndBreak "$[1]" not found for setting $[0]!'

#FIXME: Rename to SetEnvToDir().
# void SetDir(string VariableName, string Dirname)
#
# Set the passed environment variable to the passed absolute path. If there
# exists no path at this path, or there does but the path is not readable, log
# an error.
DefineFunc SetDir
+ I SetEnv $[0] $[1]
+ I PipeRead '[ -d "$[1]" ] && [ -r "$[1]" ] || \
    echo LogErrorAndBreak "$[1]/" not found for setting $[0]!'

#FIXME: Rename to SetEnvToDirAndMakeIfNeeded().
# void SetDirAndMakeIfNeeded(string VariableName, string Dirname)
#
# Set the passed environment variable to the passed absolute path. If there
# exists a path at this path but the path is not readable, log an error. On the
# other hand, if there does not exist a path, explicitly make that path.
DefineFunc SetDirAndMakeIfNeeded
+ I MakeDirIfNeeded $[1]
+ I SetDir $*

#FIXME: Rename to SetEnvToCommand().
# void SetCommand(string VariableName, string CommandName)
#
# Set the passed environment variable to the absolute path of the passed
# program on this machine. If already set, this function returns without
# modifying this variable's current value.
#
# If this program does not exist on this machine, this function currently
# sets this environment variable to the empty string and logs an error message.
# It is the caller's responsibility to handle this.
DefineFunc SetCommand
+ I SetPreferredCommand $0 $1

#FIXME: Rename to SetEnvToFirstCommand().
# void SetPreferredCommand(string VariableName, string CommandName1, ...)
#
# Sets the environment variable "VariableName", if not already set, to the
# absolute path of the first program in the string "CommandNames" of space-
# delimited program names existing on this machine. If already set, this
# function returns without modifying this variable's current value.
#
# Thus, if both "/usr/bin/aterm" and "/usr/bin/eterm" exist on this machine
# while "/usr/bin/urxvt" does not, the following call sets "FLUVIOL_XTERM_COMMAND" to
# "/usr/bin/aterm":
#
#   SetPreferredCommand "FLUVIOL_XTERM_COMMAND" "urxvt aterm eterm"
#
# If no programs in the string exist on this machine, this function currently
# sets the environment variable to the empty string and logs an error message.
# It is the caller's responsibility to handle this.
#DefineFunc SetEnvEnv
#+ I SetEnv env.name  $0
#+ I SetEnv env.value $0
DefineFunc SetPreferredCommand
+ I Test (EnvIsSet $0) LogAndBreak set $0 to "$[$0]".
+ I PipeRead '\
PREFERRED_COMMAND="$(which $[1-] 2>/dev/null | head -1)"; \
if [ -n "$PREFERRED_COMMAND" ]; then \
  echo SetEnv $[0] "$PREFERRED_COMMAND"; \
  echo "Log $[0] set to \"$PREFERRED_COMMAND\"."; \
else \
  echo "LogErrorAndBreak $[0] not set, as none of \"$[1-]\" found!"; \
fi'

# ....................{ FUNCTIONS ~ paths                  }....................
# void MakeDirIfNeeded(string Dirname)
#
# Make the directory with the passed absolute path and all parent directories of
# such directory, recursively.
DefineFunc MakeDirIfNeeded
#FIXME: Zeshify. Hmm... no, Zeshy doesn't really quite work as the default
#Fluviol shell unless we modify its behavior. Which is certainly feasible, of
#course. The principle change we'd need to make in a derivative "FluviolZeshy"
#shell is to *ALWAYS* prefix exception messages with "LogErrorAndBreak".
#Possibly simple? No idea. Interesting, however, and certainly essential.
+ I PipeRead \
 'if [ -d "$[0]" ]; then echo Nop; \
elif [ -e "$[0]" ]; then echo LogErrorAndBreak "$[0]/" not a directory!; \
else \
  echo Log making "$[0]/"...; \
  MKDIR_STDERR="$(mkdir -p "$[0]" 2>&1)"; \
  if [ $? -ne 0 ]; then \
    echo LogErrorAndBreak "$[0]/" not creatable, as: $MKDIR_STDERR!; \
  fi; \
fi'

# ....................{ FUNCTIONS ~ commands               }....................
#FIXME: Print graphical errors in addition to logging error messages on startup
#error.

# void Daemonize(string ExternalCommand, ...)
#
# Daemonize the passed external command. That is, fork a new process executing
# that command if (and only if) there is no existing process already executing
# that command. Strictly speaking, the command need not refer to a genuine
# "daemon" but may refer to a forkable command of any sort.
DefineFunc Daemonize
+ I IfNotAlreadyRunningCommand ForkCommand $[*]

# void DaemonizeAndWait(string ExternalCommand, ...)
#
# Daemonize the passed external command and wait until a process running.
DefineFunc DaemonizeAndWait
+ I IfNotAlreadyRunningCommand ForkCommandAndWait $[*]

#FIXME: Can't the check be reduced to:
#   'pidof "$[1]" 1>/dev/null 2>&1 or echo $[*]'
#Also, what's up with the odd function name?
# void IfNotAlreadyRunningCommand(string CommandName, string Function, ...)
#
# Run the passed FVWM command if the passed external program is not already
# running *AND* is installed on the current machine.
DefineFunc IfNotAlreadyRunningCommand
+ I Test (x $1) KeepRc PipeRead \
    'if ! pidof "$[1]" 1>/dev/null 2>&1; then echo $[*]; fi'
+ I TestRc (NoMatch) Log "$1" not installed... ignoring.

# void RunCommand(string CommandName)
#
# Execute the passed external command as a blocking process. That is, run that
# command and wait for that command to end before returning.
#
# This function also prints a relevant log message, for debugging.
DefineFunc RunCommand
+ I Log running "$[0]"...
+ I PipeRead '$[*] 1>&2; echo Nop'
+ I Log running "$[0]"... done.

# void ForkCommand(string CommandName)
#
# Execute the passed external command as a parallel process. That is, fork that
# command and return immediately.
#
# This function also prints a relevant log message, for debugging.
DefineFunc ForkCommand
+ I Log forking "$[0]"...
+ I Exec exec $*

# void ForkCommandAndWait(string CommandName)
#
# Execute the passed external command as a parallel process. That is, fork that
# command. Unlike the "ForkCommand" function above, this function waits for a
# new process corresponding to that command to appear in the process table.
#
# This function also prints a relevant log message, for debugging.
#FIXME: At the moment, this just hardcodes a sleep for 2 seconds. Yum. Unsure
#if the longer code, below, actually works.
DefineFunc ForkCommandAndWait
+ I Log forking "$[0]"...
+ I Exec exec $*
+ I PipeRead 'sleep 2'
+ I Log forking "$[0]"... done.
#+ I PipeRead \
#'INIT_TIME=$(date +"%s") \
#CLOSE_TIME=$(($INIT_TIME + 8))' \
#while [ ! $(pidof "$[0]") -a $(date +"%s")  ]; do; done'

# ....................{ FUNCTIONS ~ imports                }....................
# void Import(string Filename)
#
# Load and run the FVWM script with the passed absolute path.
DefineFunc Import
+ I Log loading "$[0]"...
+ I Read $[0] quiet
#FIXME: This isn't actually working. Easy to test: just pass a random path. It
#superficially appears to work, since "... failed!" never appears, but doesn't
#actually work, of course. Hmm.
+ I OrDie loading "$[0]"... failed!
#+ I OrDie cannot import "$[0]"!

#FIXME: S*w*e*e*t. We can seamlessly extend this function to support user-
#specific configuration. It's simple: just have this function first search for
#the passed path relative to $[FLUVIOL_DOT_FVWM_DIR]. If found, use that path;
#otherwise, default to $[FLUVIOL_FVWM_DIR].
#FIXME: Actually, we should never really be calling this function. Instead,
#*ALWAYS* call "Import $./${basename}". Remove all remaining references to this
#function please.

# void ImportFluviol(string Filename)
#
# Load and run the FVWM script with the passed relative path to the
# $[FLUVIOL_FVWM_DIR] directory defined above.
DefineFunc ImportFluviol
+ I Import "$[FLUVIOL_FVWM_DIR]/$[0]"

# ....................{ DEPENDENCIES                       }....................
#FIXME: Be nice to add support for importing multiple scripts at a time. Looping
#feasible in pure Zsh? Oh, right; PipeRead() it, if I recall correctly.
#FIXME: Interesting. The following command fails:
#    Import $./global/global
#Clearly, "$." does not refer to what we wanted it to. (Perhaps due to
#symlinking?) Try logging "$." to see where we currently are. *shrug*
ImportFluviol global/global
ImportFluviol input/key
ImportFluviol input/mouse
ImportFluviol menu
ImportFluviol screen

# ....................{ STARTUP                            }....................
# Run on FVWM [re]start, before running "InitFunction" and "RestartFunction".
DefineFunc StartFunction
+ I Nop
#+ I Log loading "$[FLUVIOL_RC_FILE]"...

# Run on FVWM restart, after running "StartFunction".
DefineFunc RestartFunction
+ I Log reloading "$[FLUVIOL_RC_FILE]"...

# Run on FVWM startup, after running "StartFunction". (This function is run once
# and only once; thus, it makes a respectable pad for launching daemons.)
DefineFunc InitFunction
+ I Log initializing "$[FLUVIOL_RC_FILE]"...

# Run on FVWM shutdown (and restart, before running "StartFunction").
DefineFunc ExitFunction
+ I Test (Quit) ShutdownFunction

# Run on FVWM shutdown (but not restart).
DefineFunc ShutdownFunction
+ I Log shutting down...

# ....................{ DAEMONS                            }....................
# Daemonize several commands on initial FVWM startup (but not FVWM restarts).
AddToFunc InitFunction
#FIXME: We want an FVWM function setting this.
# Dynamically adjust display properties with the XRandR X.org extension.
+ I Test (EnvIsSet FLUVIOL_XRANDR_DPI) Daemonize xrandr --dpi $[FLUVIOL_XRANDR_DPI]
#FIXME: Is the autocutsel daemon the source of the upper-left icon; and, if so,
#       can it not be hidden away via an event handler?
# Synchronize the cutbuffer (the mouse-driven cut-paste buffer, in which text
# is copied into the buffer with mouse selection and pasted from the buffer
# with mouse middle-click) with the clipboard (the keyboard-driven cut-paste
# buffer, in which text is copied into the buffer with Ctrl-c, cut with Ctrl-x,
# and pasted with Ctrl-v). Synchronizing these buffers is (generally) a good
# thing. See: http://www.nongnu.org/autocutsel
+ I Daemonize autocutsel -selection CLIPBOARD -fork
# Hide the mouse pointer after 1 second of mouse inactivity with all windows,
# including the "root window" (i.e., the desktop).
+ I Daemonize unclutter -idle 1
# Daemonize LinEAK, an XOSD-enabled application for binding keyboard media keys
# to actual commands.
# + I Daemonize lineakd

# ....................{ EVENT HANDLING                     }....................
#FIXME: This *REALLY* deserves its own component -- say, "fvwm/event".
DestroyModuleConfig FvwmEventFluviol: *

# Uncommenting the following line usefully logs FVWM events for later debugging.
#*FvwmEventFluviol: Cmd Echo

*FvwmEventFluviol: add_window     AfterCreatingWindow
*FvwmEventFluviol: destroy_window AfterDestroyingWindow
*FvwmEventFluviol: focus_change   AfterChangingWindowFocus
*FvwmEventFluviol: leave_window   AfterLeavingWindow
*FvwmEventFluviol: new_page       AfterChangingToNewPage
#*FvwmEventFluvio: windowshade AfterShadingWindow
#*FvwmEventFluvio: dewindowshade AfterUnshadingWindow
# *FvwmEventFluvio: raise_window AfterRaisingWindow
# *FvwmEventFluvio: lower_window AfterLoweringWindow

LoadModule FvwmEvent FvwmEventFluviol

# When changing pages, automatically raise the last focused window on the new
# page and set the wallpaper to that page's wallpaper.
DefineFunc AfterChangingToNewPage
# Always restore the current focused window, first. This minimizes (though,
# cannot entirely prevent) obscure race conditions.
+ I RaiseLastFocusedWindowForCurrentPage
# Set the wallpaper for this page prior to performing any other page-specific
# setting. Setting wallpaper is a time-consuming operation, and should be
# completed (and thus began) as quickly as possible. This gives a "smooth"
# transition into the page.
+ I SetWallpaperForCurrentPage

# When focusing windows, automatically shade all non-focused, shadeable
# windows, automatically focus (and defocus) all groupable windows as a group,
# and remember the newly focused window is the most recently focused window for
# the current page and desktop.
DefineFunc AfterChangingWindowFocus
#FIXME: Actually, I believe we can define a function IsThisWindowOverlappable()
#return true only on such conditions, yes? We'd need to prefix "Break" with
#"KeepRc" to prevent pollution of the return code, but this should work. How
#about:
#
#DefineFunc IsThisWindowOverlappable
#+ I ThisWindow ($[FLUVIOL_OVERLAPPABLE_WINDOW]) ReturnMatch
#+ I ThisWindow (Transient) ReturnMatch
#+ I ReturnError # ideally, ReturnNoMatch -- but unsure how to implement that
#
#Then here, write:
#
#+ I IsThisWindowOverlappable
#+ I TestRc (Match) Break
#
#O.K.; so, that'd work. But how about *THIS*:
#
#+ I ReturnIfMatch IsThisWindowOverlappable
#
#DefineFunc ReturnIfMatch
#+ I $*
#+ I TestRc (Match) Return
#
#Should work, no? Pretty concisely readable, I must admit.
# By definition, transient windows are overlappable. Since FVWM provides no OR
# condition operator, separate the two tests. (Yes, this is terrible.)
+ I ThisWindow ($[FLUVIOL_OVERLAPPABLE_WINDOW]) Break
+ I ThisWindow (Transient) Break
# Always store the currently focused window, first. This minimizes (though,
# cannot entirely prevent) obscure race conditions.
+ I StoreLastFocusedWindowForCurrentPage
+ I ShadeAllShadyUnfocusedWindows
+ I ChangeWindowFocusAsAGroup "Gimp*"

# After creating a new window, automatically raise that window.
DefineFunc AfterCreatingWindow
# By definition, transient windows are overlappable. See above.
+ I ThisWindow ($[FLUVIOL_OVERLAPPABLE_WINDOW]) Break
+ I ThisWindow (Transient) Break
+ I ThisWindow ($[FLUVIOL_MAXIMAL_WINDOW]) Maximize True 100 100
+ I ThisWindow RaiseWindowAndFocus

# After closing a focused window, automatically raise the last focused window
# for the current page.
DefineFunc AfterDestroyingWindow
+ I RaiseLastFocusedWindowForCurrentPage

# After leaving a temporary window with the mouse, automatically destroy that
# window.
DefineFunc AfterLeavingWindow
+ I ThisWindow ($[FLUVIOL_TEMPORARY_WINDOW]) Close

# ....................{ DESKTOP PAGES                      }....................
# Make each desktop a 3x3 matrix of pages (of 9 total pages), like so:
# ,-----------------------------------------------.
# | page 1: (0,0) | page 2: (0,1) | page 3: (0,2) |
# -------------------------------------------------
# | page 4: (1,0) | page 5: (1,1) | page 6: (1,2) |
# -------------------------------------------------
# | page 7: (2,0) | page 8: (2,1) | page 9: (2,2) |
# '-----------------------------------------------'
DesktopSize 3x3

# On initial startup, automatically navigate to the "middle" desktop page. As
# FVWMEvent, above, sets wallpaper on page navigation, this also has the
# indirect (but desired) effect of setting wallpaper. (We delay this page
# navigation half a second after startup - as FVWM behaves poorly to page
# navigation attempts just after startup. Let's shrug that one away, eh?)
AddToFunc InitFunction
+ I Schedule 500 GotoPage 1 1

DefineFunc WarpWindowToPage
+ I Current MoveToPage $*

# Make 4 "pan frames" (invisible windows situated at the 4 cardinal edges of
# each desktop viewport) of 1 pixel-width, each. Pan frames must be at least
# 1 pixel-width for any of the edge options, below, to be considered.
EdgeThickness 0

# Do not change the desktop viewport when moving the mouse to an edge.
EdgeScroll 0 0

# Do not change the desktop viewport when moving the mouse to an edge of the
# current desktop viewport; but do permit movement and resizement of windows
# through desktop viewports when those windows are moved at least EdgeResistance
# number of pixels past an edge of the current desktop viewport.
Style * EdgeMoveDelay 0
#FIXME: What's the proper command for this?
#Style * EdgeResistance 64
#Style *  MwmFunctions, OLDecor, GNOMEIgnoreHints

# ....................{ WINDOW PLACEMENT                   }....................
# Place windows by avoiding overlapping. (Grep "Window Manager placement" in
# "man fvwm", for unsightly details.)
Style * MinOverlapPlacement
#Style * MinOverlapPercentPlacement

# Avoid overlapping windows on higher layers or windows having EWMH strut hints.
Style * MinOverlapPlacementPenalties 1 2 0 1 0.05 50

# Avoid overlapping windows smaller than the newly placed window.
Style * MinOverlapPercentPlacementPenalties 12 6 3 1

# Ignore the EWMH working area when placing windows.
Style * EWMHPlacementUseWorkingArea

# Do not allow normal windows to place themselves.
Style * NoPPosition

# Allow transient windows to place themselves.
Style * UseTransientPPosition

# ....................{ WINDOW LIST                        }....................
# Shows a well-decorated, descriptive window list while cycling forwards and
# backwards through windows. (See "KEY BINDINGS", above.)
DefineFunc ShowWindowList
+ I WindowList ($[FLUVIOL_FOCUSABLE_WINDOW]) \
    Root c c \
    Function RaiseWindowToHeadOfWindowList \
    CurrentAtEnd \
    MaxLabelWidth 40 NoCurrentDeskTitle NoGeometry NoHotkeys \
    SelectOnRelease $[FLUVIOL_KEY_MODIFIER_SUPER_UNIX]

# ....................{ WINDOW FOCUSING                    }....................
# FVWM is ICCCM-compliant. Unfortunately, this windowing manager psuedo-standard
# permits windows to designate themselves as non-focusable - and FVWM respects
# the designation. This is particularly problematic with "broken" applications
# (e.g., Java AWT). To circumvent this, specify the "Lenience" style globally,
# permitting FVWM to conveniently overlook such formalities.
FocusStyle * Lenient

# Do not focus windows on entering them with the pointer.
FocusStyle * !EnterToFocus

# Do not unfocus windows on leaving them with the pointer.
FocusStyle * !LeaveToUnfocus

# Do not allow programs to seize the focus.
FocusStyle * !FocusByProgram

# Permit calling Focus(), but do not warp the pointer when doing so.
#FocusStyle * FocusByFunction, FocusByFunctionWarpPointer
FocusStyle * FocusByFunction, !FocusByFunctionWarpPointer

# Sort the window list by the order such windows were focused.
FocusStyle * SortWindowlistByFocus

# Automatically focus new windows.
FocusStyle * GrabFocus, GrabFocusTransient

# Automatically focus the next window when closing the currently focused window.
FocusStyle * ReleaseFocus, ReleaseFocusTransient

# Focus unfocused windows when clicking on or in those windows.
#Style * MouseFocus
FocusStyle * ClickToFocus, ClickDecorToFocus, ClickIconToFocus

# Raise focused windows when clicking on or in those windows. Coupled with the
# prior focus style, the first and second clicks on unfocused windows focus and
# raise such windows (mimicing the conventional "double click").
FocusStyle * ClickRaisesFocused, ClickDecorRaisesFocused, ClickIconRaisesFocused

# Pass clicks focusing or raising windows onto those windows.
FocusStyle * PassFocusClick, PassRaiseClick

# Pass clicks produced by pointer drags onto the clicked and dragged windows but
# do not raise such windows. This allows select text without raising windows.
FocusStyle * IgnoreRaiseClickMotion

# ....................{ WINDOW FOCUSING ~ functions        }....................
# Select the currently focused window if satisfying $[FLUVIOL_FOCUSABLE_WINDOW].
# This is of principle use in definining sensible key bindings.
DefineFunc CurrentWindow
+ I Current ($[FLUVIOL_FOCUSABLE_WINDOW]) $*

# Raise and unshade (but not focus) the current window.
DefineFunc RaiseWindow
+ I Raise
+ I WindowShade False

# Raise, unshade, and focus the current window.
DefineFunc RaiseWindowAndFocus
+ I RaiseWindow
+ I Focus

# Called by AfterChangingWindowFocus() to record the most recently
# focused window for the current page.
DefineFunc StoreLastFocusedWindowForCurrentPage
+ I All ($[FLUVIOL_RECALLABLE_WINDOW], !Focused) \
    State $[FLUVIOL_IS_WINDOW_LAST_FOCUSED] False
+ I Current ($[FLUVIOL_RECALLABLE_WINDOW]) \
    State $[FLUVIOL_IS_WINDOW_LAST_FOCUSED] True

# Called by AfterChangingToNewPage() to restore the most recently
# focused window for the current page.
DefineFunc RaiseLastFocusedWindowForCurrentPage
# If there is a recently focused window as recorded by the
# "FLUVIOL_IS_WINDOW_LAST_FOCUSED" state, focus that window.
+ I Next ($[FLUVIOL_RECALLABLE_WINDOW], State $[FLUVIOL_IS_WINDOW_LAST_FOCUSED]) \
    KeepRc RaiseWindowAndFocus
# Otherwise, focus the window nearest the mouse cursor.
+ I TestRc (NoMatch) \
    Next ($[FLUVIOL_RECALLABLE_WINDOW]) \
    RaiseWindowAndFocus

# Called by the WindowList as implementation of its window-switching.
DefineFunc RaiseWindowToHeadOfWindowList
+ I FlipFocus
+ I RaiseWindowAndFocus

# Changes window focus for windows matching the passed condition as a group.
# That is, focusing any one window matching the passed condition automatically
# causes all other windows which also match the passed condition to be focused;
# similarly, defocusing any window matching the passed condition automatically
# causes all other windows which also match the passed condition to be
# defocused.
#
# This can be used to ensure, in particular, that GiMP windows focus and defocus
# as a uniform group.
DefineFunc ChangeWindowFocusAsAGroup
+ I ThisWindow ($[0]) All ($[FLUVIOL_FOCUSABLE_WINDOW], $[0], !Raised) RaiseWindow

# When restarting FVWM, FVWM occasionally fails to restore window focus to the
# most recently focused window prior to the reset. We restore the focus, now, to
# some eligible window on the current desktop page.
AddToFunc RestartFunction
+ I None (Focused) Next ($[FLUVIOL_FOCUSABLE_WINDOW], !Shaded) RaiseWindowAndFocus

# ....................{ WINDOW SHADING                     }....................
# Shade and lower the current window.
DefineFunc ShadeWindow
+ I WindowShade True
+ I Lower

# Shade, lower, and defocus the current window; then, unshade, raise, and
# refocus the most recently focused window for the current desktop page.
DefineFunc ShadeWindowAndRaisePreviousWindow
+ I ShadeWindow
+ I Prev ($[FLUVIOL_FOCUSABLE_WINDOW], !Shaded) RaiseWindowAndFocus

# Shade all "shady," unfocused windows. (Typically, this is called when changing
# window focus away from the folque or a fluake, to shade that window.)
DefineFunc ShadeAllShadyUnfocusedWindows
+ I All ($[FLUVIOL_FOCUSABLE_WINDOW], $[FLUVIOL_SHADY_WINDOW], !Focused !Shaded) ShadeWindow

# Raise and unshade the current window, if it's shaded; or lower and shade it,
# otherwise.
DefineFunc ToggleWindowShading
+ I ThisWindow (Shaded) KeepRc ThisWindow RaiseWindowAndFocus
+ I TestRc (NoMatch)           ThisWindow ShadeWindowAndRaisePreviousWindow

# ....................{ WINDOW MOVING                      }....................
# Move windows opaquely, when the size of those windows is less than or equal to
# this percentage of the screen's size. (This redraws window content while
# moving windows for sufficiently small windows only, and outlines and hides
# window content for all larger windows.)
OpaqueMoveSize 0

# Snap windows to nearby windows and icons to nearby icons, when interactively
# moving either. "Snap" means immediately move so as to ensure the nearest
# border of the two windows or icons is precisely adjacent, while "nearby"
# means within $PIXEL_PROXIMITY pixels where "$PIXEL_PROXIMITY is the first
# argument to this style.
Style * SnapAttraction 8 SameType Screen

# ....................{ WINDOW RESIZING                    }....................
# Maximize the current window, if currently un-maximized; or restore it to its
# former, un-maximized size, if currently maximized.
DefineFunc ToggleWindowMaximization
+ I Maximize toggle 100 100

# Resize windows opaquely, by default. (This redraws window content while
# resizing windows, rather than outlining and hiding window content. The former
# can be more aesthetically pleasing, but resource consumptive.)
Style * ResizeOpaque

# Permit windows to resize themselves. (This permits Emacs, in particular, to
# override the FVWM resize hint for Emacs frames.)
Style * ResizeHintOverride

# ....................{ WINDOW INDENTIFICATION             }....................
DefineFunc IdentifyWindow
+ I All   (FvwmIdent) Close
+ I Module FvwmIdent

DestroyStyle FvwmIdent

# Prevent identification windows from siezing the focus.
Style FvwmIdent NeverFocus

# Prevent identification windows from sticking across pages.
Style FvwmIdent !StickyAcrossPages

# Prevent identification windows from being moved or resized.
Style FvwmIdent FixedPosition, FixedSize

# Prevent identification windows from appearing on window lists.
Style FvwmIdent CirculateSkip, WindowListSkip

DestroyModuleConfig FvwmIdent: *
*FvwmIdent: Back #191970
*FvwmIdent: Fore #ffffff
*FvwmIdent: Font "xft:snap"

# ....................{ WINDOW STYLES                      }....................
# Hide the window frame and titlebar for all windows. (This requires that you
# move, resize, and otherwise manipulate windows with key bindings.)
Style * !Title, !Handles, BorderWidth 0, HandleWidth 0

# Entitle windows "$[WINDOW_NAME] $[WINDOW_INDEX]", where $[WINDOW_NAME] is
# that window's exact name and $[WINDOW_INDEX] an integer between 1 and N,
# where N is the number of windows with that same exact name. (This helps us
# discern between multiple instances of that same window.)
Style * IndexedWindowName, IndexedIconName

# Window-shade windows instantaneously, without graduated animation. (This is
# arguably more efficient, but arguably less aesthetic.)
Style * WindowShadeShrinks, WindowShadeAlwaysLazy
Style * WindowShadeSteps 0

# Decorate transient windows, just as we decorate normal windows.
Style * DecorateTransient

# Prevent all windows from sticking across pages.
Style * !StickyAcrossPages

# Do not cache obscured window pixels in memory. (Caching obscured window pixels
# is beneficial when serving remote X11 clients, but otherwise not.)
Style * BackingStoreOff, SaveUnderOff

# Hide the "geometry" window when moving and resizing windows. (This window
# shows the size and state of the window being moved or resized; but,
# generally, serves more as a nuisance than assistance.)
HideGeometryWindow Move, Resize

#FIXME: Should be configurable by the user. Shunt somewhere else, ya?
# ....................{ WINDOW STYLES ~ programs           }....................
# Prevent the following windows from appearing on window lists.
Style "Speedbar*" CirculateSkip, WindowListSkip
Style "*SPEEDBAR" CirculateSkip, WindowListSkip

#FIXME: Do we have "ClickIconRaisesUnfocused" currently enabled? Do so if not.
# Prevent ToME4 from iconifying itself on losing the focus, as that plays havoc.
# And not the good kind of havoc.
Style t-engine !Iconifiable

# ....................{ CURSOR STYLES                      }....................
CursorStyle TITLE    left_ptr   blue    white
CursorStyle SYS      left_ptr   brown   white
CursorStyle DEFAULT  left_ptr   black   white
CursorStyle SELECT   crosshair  black   white
CursorStyle DESTROY  pirate     black   white
CursorStyle MENU     left_ptr   black   white
CursorStyle STROKE   left_ptr   red     white
CursorStyle ROOT     left_ptr   black   white

# Do not change the cursor when waiting for FVWM to return from blocking events.
BusyCursor * False

# ....................{ SCREENSHOTS                        }....................
#FIXME: Save files into Fluviol-specific directories: e.g.,
#   + I Exec imgname=~/pic/screenshots/`date "+%Y.%m.%d_at_%H.%M.%S"`_$[w.class].jpg \
#           && import -quality 95 -frame -window $[w.id] $imgname && FvwmCommand "function Start_viewer $imgname"

# Capture a screenshot of the entire screen.
DefineFunc ScreenshotScreen I RunCommand $[FLUVIOL_SCREENSHOT_SCREEN_COMMAND]

# Capture a screenshot of the selected window.
DefineFunc ScreenshotScreen I RunCommand $[FLUVIOL_SCREENSHOT_WINDOW_COMMAND] $[w.id]

# Capture a screenshot of the selected region.
DefineFunc ScreenshotScreen I RunCommand $[FLUVIOL_SCREENSHOT_REGION_COMMAND]

# ....................{ AUDIO VOLUME                       }....................
#FIXME: Unworking, I believe. Indeed; fix me up, please-please-please.
#DefineFunc MuteVolume  I RunCommand $[FLUVIOL_MUTE_VOLUME_COMMAND]
#DefineFunc LowerVolume I RunCommand $[FLUVIOL_LOWER_VOLUME_COMMAND]
#DefineFunc RaiseVolume I RunCommand $[FLUVIOL_RAISE_VOLUME_COMMAND]

# ....................{ XTERM CONSOLE                      }....................
# Create a new console window. This function ensures a sane environment prior to
# creating the console window: in particular, if "$[FLUVIOL_XTERM_COMMAND]" is "urxvtc",
# then this function ensures that "urxvtd" has already been executed and, if not,
# does so.
#
# Fluakes and Folques call this function on creation to create their
# underlying console windows.
DefineFunc MakeConsole
+ I Test (x $[FLUVIOL_XTERM_COMMAND]) KeepRc MakeConsoleInternal $*
+ I OrDie   $[FLUVIOL_XTERM_COMMAND] not found; not creating console!

DefineFunc MakeConsoleInternal
+ I Test (EnvMatch FLUVIOL_XTERM_COMMAND "*urxvtc") \
    DaemonizeAndWait urxvtd --opendisplay --quiet --fork
+ I Exec $*

# ....................{ FLUAKE                             }....................
#FIXME: Fairly obsolete, yes? I assume we solved this, somehow.
# Fluakes tend not to maximize properly. Specifically, console windows
# tend to align their width along strict character boundries--which increases
# the likelihood of a Fluake failing to consume all possible horizontal
# pixels on an FVWM "Maximize 100 100" command. Consequently, we brutally force
# Fluakes to consume slightly more than one screen's width of the screen.
# (This obtains the desired effect, though slightly hackily.)
#ipeRead 'echo SetEnv FLUVIOL_FLUAKE_WIDTH $(expr $[vp.width])'

DefineFunc ToggleOrMakeFluake
+ I Next ($[FLUVIOL_FLUAKE]) KeepRc ToggleFluake
+ I TestRc (NoMatch) MakeFluake

DefineFunc ToggleFluake
# If this Fluake is not maximized, forcefully guarantee it has the
# proper position and size according to the $[FLUVIOL_FLUAKE_SIZE_POSITION]
# variable. (This is rather forceful. Though it does guarantee proper window
# behaviour, it also prevents a user from customizing the unmaximized position
# or size of these windows. You may still customize their maximized position
# or size, however, via application of the "ResizeMoveMaximize" command.)
#FIXME: Oddly, I now receive the following error when uncommenting this:
#      "Unrecognised condition "Maximized" in TestRc command."
#+ I TestRc (!Maximized) SkinFluake
+ I ToggleWindowShading

AddToFunc StartFunction
# Set the number of Fluakes in current use to 0, unless already set. (As
# the "StartFunction" is called on both start and restart, this ensures that we
# do not overwrite an already extant count of the number of Fluakes.)
+ I SetEnvIfUnset FLUVIOL_FLUAKE_NAME_COUNT 0
# Destroy our record of Fluake unique names. This shouldn't be necessary,
# but is a necessary precaution.
+ I UnsetEnv FLUVIOL_FLUAKE_UNIQUE_NAME

#FIXME: I'm seeing occasional spurious behaviour from this usage of
#"FLUVIOL_FLUAKE_UNIQUE_NAME". This is clearly a terrible way of achieving this
#functionality. First of all, the variable should be renamed to
#"FLUVIOL_FLUAKE_CREATION_LOCK". What one should be really be testing, however, is for
#the existance of a console process resembling that of "urvtc" that has not
#been assigned Fluake properties. That shouldn't be terribly hard to test, no?
#
#Ah-hah! I have it. The coordinates for the current page must be passed to the
#shell command for creating fluake consoles. Then, instead of checking whether
#an environment variable is set here, check whether a command exists in the
#process list already having the coordinates for the current page. If yes,
#Break. Otherwise, create it. Simple!
#
#====================================
#I recently discovered the "InitialMapCommand" style. While I believe it only
#works on window names, I reckon that should suffice, yes? *GENIUS*, if so. It'd
#cleanly solve all the subtle issues I've hit with Fluake consoles over the years.
#====================================
DefineFunc MakeFluake
+ I Log creating fluake on ($[desk.n]:$[page.nx],$[page.ny])...
#FIXME: Can the following two commands be implemented as one command (possibly
#as the output of a piped script!), so as to eliminate deadlocks and such?
# Prevent re-entrance; that is, prevent the above "ToggleOrMakeFluake"
# function from recalling this function, if that function is still currently in
# a call to this function.
+ I Test (EnvIsSet FLUVIOL_FLUAKE_UNIQUE_NAME) Break
# Devise a unique window name for this Fluake. Why? So that, in the
# above, hypothetical case of having two Fluakes on the same page, we may
# differentiate between the old, genuine Fluake for that page and the
# newly created Fluake, which should be moved to another page.
+ I SetEnv FLUVIOL_FLUAKE_UNIQUE_NAME \
         $[FLUVIOL_FLUAKE_NAME]$[FLUVIOL_FLUAKE_NAME_COUNT]
# Log the beginning of this event as soon as possible (i.e., here!).
#+ I Log creating fluake on ($[desk.n]:$[page.nx],$[page.ny])...
# Record which page this Fluake was created on. Why? Because the user may
# move to another page after the "Exec" command finishes but before the "Wait"
# command finishes; in such an (unfortunate, but common) case, the Fluake
# will have been created on the new page to which the user moved to, and not the
# original page from which the user moved. However, the new page may already
# have had a Fluake created for it. In this case, the newly created Kuake
# console must be moved back to the page for which it was intended and for which
# there were no existing, conflicting Fluakes. Confused? So were we.
+ I SetEnv FLUVIOL_FLUAKE_CREATED_ON_PAGE_X $[page.nx]
+ I SetEnv FLUVIOL_FLUAKE_CREATED_ON_PAGE_Y $[page.ny]
# Create the Fluake, and provide it a unique icon name.
+ I MakeConsole $[FLUVIOL_FLUAKE_COMMAND_PRE] \
                $[FLUVIOL_FLUAKE_COMMAND_ICON_NAME] $[FLUVIOL_FLUAKE_UNIQUE_NAME] \
                $[FLUVIOL_FLUAKE_COMMAND_POST]
# Wait for its appearance. We cannot wait on window icon names, in FVWM; so,
# wait on its window name, instead.
+ I Wait "$[FLUVIOL_FLUAKE_NAME]"
# Style this Fluake. Conditions, unlike the "Wait" command, can select
# window icon names. Thus, as that provides a more specific condition, we select
# on its icon name. (Among other things, this moves this Fluake to its
# proper page, if needed).
+ I Next ("$[FLUVIOL_FLUAKE_UNIQUE_NAME]", CirculateHit) \
    StyleFluake $[FLUVIOL_FLUAKE_CREATED_ON_PAGE_X] \
                $[FLUVIOL_FLUAKE_CREATED_ON_PAGE_Y]
# Increment our count of the number of Fluakes, now.
+ I PipeRead \
  'echo SetEnv FLUVIOL_FLUAKE_NAME_COUNT $(expr $[FLUVIOL_FLUAKE_NAME_COUNT] + 1)'
# Destroy our record of which page this Fluake was created on, now that
# we have created it.
+ I UnsetEnv FLUVIOL_FLUAKE_CREATED_ON_PAGE_Y
+ I UnsetEnv FLUVIOL_FLUAKE_CREATED_ON_PAGE_X
# Destroy our record of this Fluake's unique name. This should be last.
+ I UnsetEnv FLUVIOL_FLUAKE_UNIQUE_NAME
# Log the ending of this event as late as possible (i.e., here!).
+ I Log creating fluake on ($[desk.n]:$[page.nx],$[page.ny])... done.

# Style the newly created Fluake.
DefineFunc StyleFluake
+ I MoveToPage $0 $1
+ I SkinFluake

# Skin the current window: hopefully, a Fluake. This establishes this
# console's window position and size, among other window properties.
DefineFunc SkinFluake
# First, establish this console's unmaximized window position and size.
# Then, maximize this console. (By decoupling window maximization from window
# positioning and sizing, we allow unmaximization of console windows to the
# unmaximized window position and size below. Surely, it is sweet.)
+ I ResizeMoveMaximize $[FLUVIOL_FLUAKE_SIZE_POSITION]

DestroyStyle Fluake

# Prevent Fluakes from having their focus siezed by new windows.
Style Fluake FPOverrideGrabFocus, EWMHMaximizeIgnoreWorkingArea

# Prevent Fluakes from appearing on the window list.
Style Fluake WindowListSkip, CirculateSkip

# Prevent Fluakes from resizing themselves.
Style Fluake FixedSize

# ....................{ FOLQUE                             }....................
DefineFunc ToggleOrMakeFolque
+ I All    ($[FLUVIOL_FOLQUE]) KeepRc ToggleWindowShading
+ I TestRc (NoMatch)            MakeFolque

DefineFunc MakeFolque
+ I KillFolque
+ I Log creating folque...
+ I MakeConsole $[FLUVIOL_FOLQUE_COMMAND]
+ I Wait "$[FLUVIOL_FOLQUE_NAME]"
+ I All ($[FLUVIOL_FOLQUE]) StyleFolque
+ I Log creating folque... done.

DefineFunc KillFolque
+ I All ($[FLUVIOL_FOLQUE]) Silent Close
+ I TestRc (Match) Log killed folque...

# Minimize Folque to a single-line, small-width console situated just
# slightly above the lower-left edge of the screen.
DefineFunc StyleFolque
+ I ThisWindow ResizeMove $[FLUVIOL_FOLQUE_SIZE_POSITION]

DestroyStyle Folque

# Share Folque across every desktop and desktop page.
Style Folque Sticky

# Allow Folque to have their focus siezed by new windows.
Style Folque FPOverrideGrabFocus, EWMHMaximizeIgnoreWorkingArea

# Prevent Folque from appearing on the window list.
Style Folque WindowListSkip, CirculateSkip

# Allow Folque to move or resize itself.
Style Folque VariablePosition, VariableSize

# ....................{ WALLPAPER ROTATION                 }....................
# Schedule wallpaper rotation.
AddToFunc StartFunction
+ I ScheduleWallpaperRotation

DefineFunc ScheduleWallpaperRotation
+ I Test (!EnvIsSet FLUVIOL_WALLPAPER_COMMAND) \
    LogErrorAndBreak not scheduling wallpaper rotation, as no wallpaper programs found!
+ I Log scheduling wallpaper rotation...
+ I Deschedule $[FLUVIOL_WALLPAPER_SCHEDULE_ID]
+ I   Schedule Periodic \
    $[FLUVIOL_WALLPAPER_SCHEDULE_MS] \
    $[FLUVIOL_WALLPAPER_SCHEDULE_ID] RotateWallpapers

# Rotate wallpapers on initial startup.
AddToFunc InitFunction
+ I RotateWallpapers

# Sets the wallpaper for the passed desktop page (where the first and second
# arguments to this function are the X- and Y- coordinates of the page,
# respectively), to the randomly selected image as previously cached by the
# "RotateWallpaper" function. If necessary, this performs that rotation now.
#
# "Setting wallpaper," typically, means painting the external image for that
# wallpaper onto the root window (beneath all other windows for the current
# desktop page). This is a (somewhat) complex process. Neither FVWM or the
# simple slew of Bourne shell-scripts, below, are able to "set wallpaper."
# Instead, you must install an external application to do this for you.
#
# See "FLUVIOL_WALLPAPER_COMMAND," above, for details.
DefineFunc SetWallpaperForCurrentPage
+ I Test (!EnvIsSet FLUVIOL_WALLPAPER_COMMAND) Return
+ I Test (!r "$[FLUVIOL_WALLPAPER_CACHE_HOME]/$[page.nx].$[page.ny]") RotateWallpapers
+ I Test (!r "$[FLUVIOL_WALLPAPER_CACHE_HOME]/$[page.nx].$[page.ny]") Break
+ I Exec exec $[FLUVIOL_WALLPAPER_COMMAND] $[FLUVIOL_WALLPAPER_ARGUMENTS] \
             "$[FLUVIOL_WALLPAPER_CACHE_HOME]/$[page.nx].$[page.ny]"

# Rotates wallpaper. This makes a new directory (under FVWM-Crystal, this is
# "~/.fvwm-crystal/wallpapers/"), having symlinks to images to be used as
# wallpaper for desktop pages. Specifically, this directory has one symlink
# named "${PAGE_X}.${PAGE_Y}" for every desktop page, where ${PAGE_X} and
# ${PAGE_Y} is the X- and Y-coordinates for the page. The upper-left-hand page,
# for example, has X- and Y-coordinates (0, 0); and therefore has one symlink
# named "0.0" in this directory, linking to the image to be used as wallpaper
# for that page.
#
# This directory is the "target" directory. It caches our selection of which
# wallpaper to use on which desktop page. The "SetWallpaper" function, above,
# uses this cache to switch desktop page wallpaper when switching desktop pages.
#
# The target directory has symlinks to images residing under subdirectories of
# the source directory. The source directory, in turn, has one subdirectory for
# each desktop page. See "FLUVIOL_WALLPAPER_HOME," above, for a terse synopsis of
# this substructure.
#
# We select subdirectories from the source directory in "ls" order,
# alphabetically. This lets you explicitly control the assignment of
# alphabetic subdirectories to desktop pages, by renaming those subdirectories
# in accordance with "ls" order. In this way, a subdirectory named "0~nature/"
# will probably have its images assigned to the first desktop page, "1~girls/"
# will probably have its images assigned to the second desktop page, and so on.
#
# If the source directory has less subdirectories than you have defined
# desktop pages, we reuse the last subdirectory in this directory for all
# desktop pages for which there is no corresponding subdirectory.
#
# If the source directory has more subdirectories than you have defined
# desktop pages, we ignore all "later" subdirectories for which there is no
# corresponding desktop page.
#
# If the source directory has no subdirectories at all, we fail with error.
#
# This function is written in Bourne shell-script and a wee dabbling of `awk`,
# so as to run cross-portably and (more decisively) without requiring your
# installation of external scripts, scripting languages, or other crass
# dependencies. Wallpaper rotation is a brute, simple process; and, being simply
# implementable in Bourne shell, shouldn't ever require heavier scripting or
# implementation lifting.
#
# This function randomly selects one source wallpaper file from each source
# wallpaper subdirectory by: feeding awk a newline-separated list of source
# wallpaper files for each source wallpaper subdirectory, seeding awk's
# psuedorandom number generator with an unsigned 4-byte integer, selecting a
# psuedorandom number between [1, NF] where "NF" is the number of source
# wallpaper files for the source wallpaper subdirectory, and returning the
# psuedorandom number-eth source wallpaper file. We manually seed awk's
# psuedorandom number generator, as awk's default seed (some function of the
# current date) often generates non-psuedorandom numbers.
#
# This function, admittedly, may be subtly error-prone--as Bourne shell-scripts
# are wont to be. That said, I have stably run it for some months. Your mileage
# may vary. (But I hope it treats you well.)
DefineFunc RotateWallpapers
+ I Test (!r "$[FLUVIOL_WALLPAPER_HOME]") \
    LogErrorAndBreak wallpapers not found at $[FLUVIOL_WALLPAPER_HOME]!
+ I Log rotating wallpapers...
+ I PipeRead '\
if [ ! -d "$[FLUVIOL_WALLPAPER_CACHE_HOME]" ]; then \
  echo "Log making $[FLUVIOL_WALLPAPER_CACHE_HOME]..."; \
  mkdir -p "$[FLUVIOL_WALLPAPER_CACHE_HOME]"; \
fi'
+ I Exec \
PAGE_X_MAX=$(expr $[desk.pagesx] - 1); \
PAGE_Y_MAX=$(expr $[desk.pagesy] - 1); \
PAGE_CUR=0; \
\
for PAGE_X in $(seq 0 $PAGE_X_MAX); do \
for PAGE_Y in $(seq 0 $PAGE_Y_MAX); do \
  PAGE_CUR=$(expr $PAGE_CUR + 1); \
  SEED=$(date +'%N'); \
\
  WALLPAPER_TARGET_FILE="$[FLUVIOL_WALLPAPER_CACHE_HOME]/${PAGE_X}.${PAGE_Y}"; \
  FLUVIOL_WALLPAPER_HOME=$(ls -1dF "$[FLUVIOL_WALLPAPER_HOME]"/* | \
  awk -v CF=$PAGE_CUR '\
    BEGIN { RS = ""; FS = "\n" } \
    END { if (CF > NF) CF = NF; print $CF }'); \
  WALLPAPER_SOURCE_FILE="$FLUVIOL_WALLPAPER_HOME"$(ls -1 "$FLUVIOL_WALLPAPER_HOME" | \
  awk -v SEED="$SEED" '\
    BEGIN { RS = ""; FS = "\n"; srand(SEED) } \
    END { RF = int(rand()*NF + 1); print $RF }'); \
\
  rm "$WALLPAPER_TARGET_FILE"; \
  ln -s "$WALLPAPER_SOURCE_FILE" "$WALLPAPER_TARGET_FILE"; \
done; \
done
+ I Log rotating wallpapers... done.

# --------------------( WASTELANDS                         )--------------------
# * It's time. Github this already. We're risking catastrophic failure with our
#   laziness -- and that's just not cool, bro.
# Import user-configured key bindings. Do so after resolving whether we are
# running under FVWM-Crystal, since numerous bindings depend on this fact.
# void SetReturnCodeToBreak(void)
#
# Set the current return code to "Break" (i.e., -2), signifying a premature
# return from the prior function.
#DefineFunc SetReturnCodeToBreak
#+ Break

# ....................{ FUNCTIONS ~ conditionals           }....................
#FIXME: These look great. Test and begin using elsewhere (i.e., replacing
#"TestRc (NoMatch)" with "Else").

#FIXME: Sadly, neither of the two commands work. They run, but fail to properly
#test the expected condition. The manual gives the reason why: "Important note:
#return codes... are not inherited by sub functions." In other words, FVWM
#localizes $[wc.cond] to each function. A tad annoying. We can't really work
#around that, so... shunt these. *sigh*

# void If(string Conditions, string Function)
#
# Call the passed function if the passed "Test" condition(s) match.
#DefineFunc If
#+ I Test $*

# void Then(string Function)
#
# Call the passed function if the prior "Test" condition(s) succeeded.
#DefineFunc Then
#+ I TestRc (Match) $*

# void Else(string Function)
#
# Call the passed function if the prior "Test" condition(s) failed.
#DefineFunc Else
#+ I TestRc (NoMatch) $*

#FIXME: ...why not?
# Do not "pass" the click used to focus or raise windows onto those windows as a
# normal click.
#FocusStyle * PassFocusClick, !PassRaiseClick

#FIXME: This isn't quite right. Since we import "global" above, its log messages
#appear prior to these in "~/.xsession". We should probably just call these
#straight from the top-level prior to importing "global" -- ideally, immediately
#after .
# "/usr/share/fvwm/fluviol/" if such
# directory exists or die.
#SetEnvIfUnset FLUVIOL_HOME "$[.]"
#DefineFunc SetEnv_FLUVIOL_HOME
#+ I Test (r "/usr/share/fvwm/fluviol") \
#    SetEnv FLUVIOL_HOME "/usr/share/fvwm/fluviol"
#+ I OrDie "FLUVIOL_HOME not set and \"/usr/share/fvwm/fluviol/\" not found!"

#If (!EnvIsSet FLUVIOL_HOME) SetEnv_FLUVIOL_HOME

#FIXME: Not the best name. "Use", "Require", who-knows-what?

# *WAIT*. IS THIS EVEN DOING ANYTHING, at the moment? It should be "dying"
#in some respect, as "/usr/share/fvwm/fluviol" doesn't exist. I see nothing...
# ....................{ PATHS ~ system                     }....................
# Absolute path of the system-wide Fluviol configuration script.
#SetFile FLUVIOL_GLOBAL_FILE ""
